[TOC]

# 反射【重点】

## 1. 反射概述

### 1.1 Java文件和.class文件之间的关系

```text
Java文件
	Java文件中包含代码的所有内容，类，接口，成员变量，成员方法....

.class字节码问题
	.java文件 通过 javac编译工具生成对应的.class字节码文件
	使用JDK中提供的反编译工具，可以看到.class文件中包含 
		Class 完整的包名.类名
		Field 成员变量，成员变量的名字和成员变量的数据类型[如果是引用数据类型，也是
			完整的包名.类名]
		Method 成员方法，方法权限修饰符，返回值类型，方法名，形式参数列表数据类型

总结：
	.class字节码文件中，包含了Java文件的所有内容
```

![](F:\千锋自主学习\Day25\img\反编译class1.png)

![](F:\千锋自主学习\Day25\img\反编译class2.png)

### 1.2 程序加载过程和.class文件的关系

```text
	在Java文件运行过程中，当前程序需要哪一个类参与代码执行，那么就需要加载这个类的.class字节码文件，该.class字节码文件是在程序的加载阶段，存在于内存的【代码区】
	
	.class字节码文件既然加载到内存的【代码区】
	.class文件中包含对应Java程序的所有内容
	代码区存在一块空间 ==> .class ==> Java程序的所有内容
```

### 1.3 Java中的万物皆对象

```text
	在Java代码中，把在内存代码区保存的.class字节码内存空间，看做是一个对象。而该对象中包含了对应Java文件的所有内容。
```

![](F:\千锋自主学习\Day25\img\class文本保存在内存的代码区.jpg)

### 1.4 Class到底是什么？

```java
class Person {
    int age;
    String name;
    
    public Person() {}
    
    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }
    
    public void test() {
        sout("方法");
    }
}

class Dog {
    String name;
    char gender;
    
    public Dog() {}
    
    public Dog(String name, char gender) {
        this.name = name;
        this.gender = gender;
    }
    
    public void eat() {
        sout("狗狗吃肉");
    }
}
```

![](F:\千锋自主学习\Day25\img\class的引出.jpg)

## 2. 反射必会的方法【重点】

### 2.1 Class涉及到的方法

```text
Class Class.forName(String packageNameAndClassName);
	Class类的静态成员方法，通过完整的包名.类名获取对应.class文件的Class对象
    同时也可以作为.class文件加载的方法。

Class 类名.class;
    通过类名.class方法，获取对应的Class类对象，通常用于方法的参数类型。

Class 类对象.getClass();
	通过类对象获取对应.class的Class类对象，方法参数，或者说数据类型判断。
```

```java
package com.shawn_b_reflect;
/**
 * 狗狗类
 * @author shawnzhao
 * @version 创建时间: 2021年4月29日 下午2:30:32
 *
*/
public class Dog {

	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "Dog [name=" + name + "]";
	}
}
```

```java
package com.shawn_b_reflect;
/**
 * Person 人类
 * @author shawnzhao
 * @version 创建时间: 2021年4月29日 下午2:33:05
 *
*/
public class Person {

	public String phone;
	
	public void eat() {
		
	}
}
```

```java
package com.shawn_b_reflect;
/**
 * 学生类
 * @author shawnzhao
 * @version 创建时间: 2021年4月29日 下午2:33:31
 *
*/

import com.shawn_a_annotation.MyAnnotation;

/**
 * 利用反射机制读取当前类中的所有信息
 * 生成对象，执行方法，并给属性赋值
 * 反射和配置文件的配合可以生成任何对象，调用任何方法
 * @param <T>
 * @param <T>
 */
public class Student extends Person implements Comparable {

	private String name;
	private int age;
	public String sex;
	
	public Student() {
		super();
	}

	public Student(String name, int age, String sex) {
		super();
		this.name = name;
		this.age = age;
		this.sex = sex;
	}

	public String getName() {
		return name;
	}

	public void setName(String name, int age) {
		this.name = name;
		this.age = age;
	}
	
	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
	
	public void setAge(String name,int age) {
		this.name = name;
		this.age = age;
	}

	public String getSex() {
		return sex;
	}

	public void setSex(String sex) {
		this.sex = sex;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", sex=" + sex + "]";
	}

	@Override
	public int compareTo(Object o) {
		// TODO Auto-generated method stub
		return 0;
	}

	@MyAnnotation
	private void getInfo() throws Exception {
		System.out.println(this.name + " " + this.age + " " + this.sex);
	}
	
}
```

```java
package com.shawn_b_reflect;

import java.lang.reflect.Method;

import com.shawn_b_reflect.Student;;

/**
 * 利用反射
 * @author shawnzhao
 * @version 创建时间: 2021年4月29日 下午2:53:24
 *
*/
public class Test {

	public static void main(String[] args) throws Exception {
		
		Student student = new Student();
		student.setAge(10);
		student.setName("tom");
		// 反射是通过一系列代码的方式来创建对象，通过代码的方式来调用方法，
		// 通过代码的方式来赋值属性
		
		// 1. 获取class
		
		// 一个类 只能有一个 Class 类
		Class c1 = Student.class;
		
		// 在明确知道对象的前提条件下，通过 对象.getclass() 方法 调用Object类中的方法
		Class c2 = student.getClass();
		
		Class c3 = Class.forName("com.shawn_b_reflect.Student");
		
		System.out.println(c1);
		System.out.println(c2);
		System.out.println(c3);
		
		// 2. 使用反射，创建对象，以及调用方法
		Object object = c1.newInstance();
		
		// 3. 得到了方法
		Method method = c1.getMethod("setAge", int.class);
		
		// 4. 调用方法
		method.invoke(object, 20);
		
		Method method2 = c1.getMethod("setName", String.class);
		method2.invoke(object, "麦林炮手");
		
		// 5. 打印输出
		System.out.println(object);
	}
	
}
```

### 2.1.1 properties实现反射

```java
package com.shawn_b_reflect;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.Properties;

import org.omg.CORBA.StringHolder;

/**
 * 反射机制的引入
 * @author shawnzhao
 * @version 创建时间: 2021年4月29日 下午2:39:19
 *
*/
public class TestProperties {

	public static void main(String[] args) throws Exception {
		
		// 读取配置文件
		Properties properties = new Properties();
		properties.load(new FileInputStream("class.properties"));
		
		// 根据 key 读取文件中对应的 value 返回值是 String 类型
		String className = properties.getProperty("className");
		String methodName = properties.getProperty("methodName");
		String methodValue = properties.getProperty("methodValue");
		System.out.println(className);
		System.out.println(methodName);
		System.out.println(methodValue);
		
		// 利用反射机制
		// 1. 获取class
		Class c1 = Class.forName(className);
		Object object = c1.newInstance();
		// Method method = c1.getMethod(methodName, String.class);
		Method method = c1.getMethod(methodName, String.class);
		method.invoke(object, methodValue);
		System.out.println(object);
	}
}
```

### 2.2 Constructor 构造方法类涉及到的方法

```text
public Constructor[] getConstructors();
	获取当前Class类对象对应Java文件中，所有【public修饰构造方法的类对象数组】
	
public Constructor[] getDeclaredConstructors();
	【暴力反射】
	获取当前Class类对象对应Java文件中，所有【构造方法的类对象数组】，包括私有化构造方法。
	
【回顾】
	new Person();
	new Person(1);
	因为这里利用了重载的知识点，会根据实际【参数类型】，来选择对应的构造方法。
【推理】
	通过Class类对象，获取指定构造方法，需要根据构造方法的所需的参数数据类型来完成。

public Constructor getConstructor(Class... initArgumentTypes);
	根据指定的数据类型，来选择对应的构造方法，这里可能会抛出异常。
	这里有且只能获取类内的指定数据类型public修饰构造方法类对象
	Class: 约束数据类型，当前方法所需的参数类型
		例如: 
			这里需要int类型 int.class
			这里需要String类型 String.class
			这里需要Perosn类型 Person.class
		异常:
			NoSuchMethodException
	... : 不定长参数
		构造方法需要的参数类型是很多的，有可能无参数，有可能有参数。... 不定长参数
		类约束使用，增强代码的普适性
		例如:
			这里无参数 () or (null)
			参数类型int类型 (int.class)
			参数类型int, String类型 (int.class, String.class)
	initArgumentTypes:
		参数名 初始化参数类型复数
		
public Constructor getDeclaredConstructor(Class... initArgumentTypes);
	【暴力反射】
	根据指定的数据类型，来选择对应的构造方法，这里可能会抛出异常。
	这里可以获取指定参数类型私有化构造方法和非私有化构造方法
	Class: 约束数据类型，当前方法所需的参数类型
		例如: 
			这里需要int类型 int.class
			这里需要String类型 String.class
			之类需要Perosn类型 Person.class
		异常:
			NoSuchMethodException
	... : 不定长参数
		构造方法需要的参数类型是很多的，有可能无参数，有可能有参数。... 不定长参数
		类约束使用，增强代码的普适性
		例如:
			这里无参数 () or (null)
			参数类型int类型 (int.class)
			参数类型int, String类型 (int.class, String.class)
	initArgumentTypes:
		参数名 初始化参数类型复数
		
Object newInstance(Object... initArguments);
	通过Constructor对象来调用，传入当前构造方法所需创建对象的初始化参数，创建对象。
	Object: Object类是Java中所有类的基类，这里可以传入任意类型的参数
	... : 不定长参数，因为Constructor类对象在获取的过程中，约束的参数个数都不确定，
	这里使用不定长参数来传入数据
```

```java

```

### 2.3 Method成员方法涉及到的方法

```text
问题:
	请问调用执行成员方法时，有哪些需要考虑的内容？
		调用者
			类名，对象
		方法名
		参数
	
	如果需要通过Class对象来获取Method对象，你认为有哪些必要的内容需要考虑?
		参数
		方法名
		权限修饰符
```

```text
Method[] getMethods();
	获取类内所有public修饰的成员方法，包括从父类继承而来的public修饰方法。

Method[] getDeclaredMethods();
	暴力反射
	获取类内所有成员方法，但是不包括从父类继承而来的方法。

Method getMethod(String methodName, Class... parameterTypes);
	根据指定的方法名和对应的参数类型，获取对应的public修饰的成员方法
	methodName: 
		方法名，指定获取的是哪一个方法
	parameterTypes:
		Class用于约束当前使用的参数数据类型
		... 不定长参数，方法参数个数，顺序，有参无参问题
	例如：
		cls是Class类对象
		cls.getMethod("setName", String.class);
		cls.getMethod("getName");		

Method getDeclaredMethod(String methodName, Class... parameterTypes);
	根据指定的方法名和对应的参数类型，获取对应的成员方法，包括私有化成员方法，但是不
	包括从父类继承而来的方法
	methodName: 
		方法名，指定获取的是哪一个方法
	parameterTypes:
		Class用于约束当前使用你的参数数据类型
		... 不定长参数，方法参数个数，顺序，有参无参问题
	例如：
		cls是Class类对象
		cls.getMethod("setName", String.class);
		cls.getMethod("getName");		

Object invoke(Object obj, Object... arguments);
	通过Method类对象调用，执行对应的方法，需要的参数
	obj : 
		执行当前方法的执行者
	arguments:
		Object... 不定长参数，当前方法执行所需的实际参数，
```

```java
	/**
	 * 使用类中的方法
	 * 
	 * @throws Exception
	 */
	@Test
	void test3() throws Exception {
		
		// 1. 获取class
		Class class1 = Student.class;
		
		// 2. 调用无参构造器(获取对象)
		Object object = class1.newInstance();
		
		// 3. 获取class中的setName() 方法
		Method method = class1.getMethod("setName", String.class, int.class);
		
		// 4. 将方法赋值
		method.invoke(object, "tom",10);
		
		// 5. 获取方法值
		System.out.println(object);
		
		// 6. 获取class中的私有方法 getInfo()
		Method m1 = class1.getDeclaredMethod("getInfo");
		
		// 7. 提升使用私有方法的权限
		m1.setAccessible(true);
		
		// 8. 获取方法值
		m1.invoke(object);
	}
	
	
	/**
	 * 获取类中所有的方法
	 * @throws Exception
	 */
	@Test
	void test2() throws Exception {
		
		// 1. 获取 class
		Class class1 = Student.class;
		
		// 2. 调用无参构造器(获取对象)
		Object object = class1.newInstance();
		
		// 3. 获取类中的所有方法(数组为返回值)包括私有的
		Method[] methods = class1.getDeclaredMethods();
		
		// 4. 使用增强for循环取值
		for (Method method : methods) {
			Annotation[] annotations = method.getAnnotations();
			for (Annotation annotation1 : annotations) {
				System.out.println(annotation1.toString());
			}
			
			// 5. 获取方法的修饰符
			System.out.print(Modifier.toString(method.getModifiers()) + " ");
			
			// 6. 获取方法中的返回值类型
			System.out.print(method.getReturnType().getName()+" ");
			
			// 7. 获取方法中的方法名
			System.out.print(method.getName());
			
			// 8. 判断方法中的形式参数个数有几个并且赋值
			if (method.getParameterCount() > 0) {
				System.out.print("(");
				
				// 9. 获取形式参数列表，返回的是一个数组
				Parameter[] parameters = method.getParameters();
				
				// 10. 使用增强for 循环取值
				for (Parameter parameter : parameters) {
					System.out.print(parameter.getType().getName() + ",");
				}
				
				System.out.println(")");
			}
			
			// 11. 获取方法中的异常类型
			Class[] types = method.getExceptionTypes();
			if (types.length != 0) {
				System.out.print(" throws ");
			}
			for (Class type : types) {
				System.out.print(type.getName());
			}
			System.out.println();
		}
	}
```

### 2.4 Field成员变量涉及到的方法

```text
Field[] getFields();
	获取类内所有public修饰的成员变量
Field[] getDeclaredFields();
	获取类内所有成员变量，包括私有化成员方法

Field getField(String fieldName);
	获取指定变量名的成员变量对象，要求是public修饰的成员变量

Field getDeclaredField(String fieldName);
	获取指定变量名的成员变量对象，包括private私有化修饰的成员变量
	
void set(Object obj, Object value);
	设置指定调用者中对应成员变量的数据
	obj : 调用者
	value: 对应当前成员变量需要赋值的内容
Object get(Object obj);
	获取指定调用者中指定成员变量的数据
	obj: 调用者
```

```java
/**
	 * 使用属性
	 * @throws Exception
	 */
	@Test
	void test1() throws Exception {
	
		// 1. 获取 class
		Class class1 = Student.class;
		
		// 2. 调用无参构造(获取对象)
		Object object = class1.newInstance();
		
		// 3. 获取类中的私有属性
		Field field = class1.getDeclaredField("name");
		
		// 4. 私有的属性在使用时需要提升下权限
		field.setAccessible(true);
		
		// 5. 对属性进行赋值
		field.set(object, "麦林炮手");
		
		// 6. 获取属性值
		Object object2 = field.get(object);
		
		System.out.println(object2);
	}
	
	/**
	 * 获取类中的所有属性
	 * @throws Exception
	 */
	@Test
	void test() throws Exception {
		
		// 1. 获取class
		Class class1 = Student.class;
		
		// 2. 根据 class 来创建对象
		Object object = class1.newInstance();
		
		// 3. 通过 class 来获取对象的所有属性(包括私有的属性)
		Field[] fields = class1.getDeclaredFields();
		for (Field field : fields) {
			
			// 4. 获取属性中的 修饰符
			System.out.println(Modifier.toString(field.getModifiers()) + "");
		
			// 5. 获取属性中的 数据类型
			System.out.println(field.getType().getName());
			
			// 6. 获取属性中的 属性名
			System.out.println(field.getName());
		}
	}
```

### 2.5 给予暴力反射私有化内容的权限操作

```text
setAccessible(boolean flag);
给予Constructor，Method, Field对象，私有化内容，操作权限设置
true表示可以操作
```

 

